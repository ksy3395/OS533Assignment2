So we began this project by creating a new directory and importing the assembly files from the previous assignment. We used the queue.h and queue.c files provided by Mike which included the structure for queues and the enqueue, dequeue and isEmpty functions. Then we followed the instructions to set up our thread structure in scheduler.h file along with four function besides thread_wrap. So in the project, to free the memory properly, we implemented the temporary stack pointer to be fixed at the base of stack. We have also added this as a variable of the thread structure so it can be freed easily. We have temp_sp because the original stack pointer of the stack never points to the base when we are ready to free it.

So we have three global thread pointers. The current_thread points to the thread executing at a particular point in time. The new_thread used in thread_fork is initialised and swapped with the current_thread in thread_start. The next_thread used in yield is used to store the dequeued the thread which will now be put in RUNNING state after a swap in thread_switch. We consider a thread’s function to be done in the thread_wrap function when the thread returns from the prime function and so we set its status to DONE. We also create a new queue called done_list to enqueue threads that are done with the execution. In scheduler_end we do a first while check till the ready queue is empty to continue to execute the threads there till they print prime number. The second while check is to dequeue each done thread in our done_list and freeing the memory occupied by these threads.

Discussion Question 1: In our code, we free memory in scheduler_end. A more intuitive way would be to free the memory as and when the thread is done with its execution, i.e., before scheduler_end is called. We reduce allocations and deallocations by assigning a smaller STACK_SIZE to malloc like 512KB so this will reduce the amount of unused stack space, if any. 

Discussion Question 2: Yes, we are executing scheduler code in a thread. The thread executing at an y point in time depends on what is being execute. For example, if we are executing thread_fork, main will be executing. When we execute yield, it depends on which thread is executing: it could be thread 1 with value 20 trying to enqueue (if it is not DONE) and dequeue thread 2 with value 10. The precise point when we stop running one thread’s code and start running another is when we swap the stack pointers in assembly code with: movq %rsp, (%rdi) and movq (%rsi), %rsp and we jump to thread_wrap to start executing another thread.

Discussion Question 3: In a threading API, we would like to do more advanced functions like joining threads and running multiple threads at the same time. We would also like to have functions that process I/O calls. Multi-threaded application requires multiple threads to be running at the same time so application such as image processing and animation rendering.
